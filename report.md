# Звіт з лабораторної роботи №4

## Загальна інформація
- ПІБ студента: Величко Ростислав Володимирович
- Група: ІПЗ-32
- Варіант (предметна область): Автосервіс
- Рівень виконання: 2-3

## Опис предметної області
Інформаційна система "Автосервіс" призначена для автоматизації роботи автосервісного центру. В системі ведеться облік клієнтів та їхніх автомобілів, реєстрація замовлень на обслуговування, та моніторинг виконання послуг. Основні типові операції включають:
-   Реєстрація клієнтів: збереження інформації про нових клієнтів та їхніх автомобілів.
-   Облік автомобілів: додавання автомобілів клієнтів до системи та прив’язка їх до власників.
-   Створення замовлень: оформлення замовлення на ремонт або сервіс, вибір автомобіля клієнта, призначення відповідального працівника та переліку послуг.
-   Облік послуг: ведення списку стандартних послуг з фіксованими цінами.
-   Виконання та закриття замовлень: фіксація факту виконання послуг, розрахунок загальної вартості, зміна статусу замовлення.
-   Генерація рахунків: автоматичне створення рахунку за виконані роботи для клієнта, з детальним переліком послуг і цін.
-   Статистика і звітність: отримання зведеної інформації про кількість замовлень і доходи по місяцях, резервне копіювання бази даних.

## Концептуальна модель
Опис сутностей та їх атрибутів:
-   Employee (Працівник): містить дані про працівників сервісу (наприклад, механіків, менеджерів). Основні атрибути: унікальний ID працівника, ім’я (логін) для входу, роль (наприклад, _admin_ для адміністратора) та пароль (в лабораторній використовується простий хеш чи текстовий пароль).
-   Client (Клієнт): представляє клієнтів автосервісу. Атрибути: ID клієнта, ім’я (або назва клієнта), контактна інформація (телефон, email тощо).
-   Car (Автомобіль): інформація про автомобілі, що обслуговуються. Атрибути: ID автомобіля, марка, модель, державний номер. Автомобіль пов’язаний з конкретним клієнтом-власником (через зовнішній ключ на Client).
-   Order (Замовлення): заявка на сервісне обслуговування. Атрибути: ID замовлення, дата створення, статус замовлення, загальна вартість. Замовлення пов’язане з клієнтом, автомобілем і відповідальним працівником (містить зовнішні ключі на Client, Car та Employee).
-   Service (Послуга): довідник сервісних послуг, що надаються. Атрибути: ID послуги, назва послуги, ціна за одиницю (наприклад, за одну роботу чи деталь).
-   OrderItem (Позиція замовлення): деталізація послуг в межах конкретного замовлення. Атрибути: посилання на замовлення (Order ID), посилання на послугу (Service ID), кількість одиниць даної послуги. Кожен запис відповідає окремій послузі, виконаній в рамках замовлення; використовується для підрахунку вартості замовлення.
Зв’язки між сутностями: Один клієнт може мати декілька автомобілів; кожен автомобіль належить одному клієнту. Один клієнт може зробити багато замовлень, але кожне замовлення прив’язане до конкретного клієнта і конкретного автомобіля. Кожне замовлення виконується одним працівником, але працівник може обслуговувати багато замовлень. Замовлення містить багато позицій (послуг), а кожна послуга може зустрічатися у багатьох замовленнях (через таблицю OrderItem, яка є асоціативною сутністю). Таким чином, OrderItem пов’язує замовлення і послуги, забезпечуючи структуру «замовлення – перелік послуг».

<a href="https://ibb.co/NzqmV57"><img src="https://i.ibb.co/MLHG2r9/51157327-8b0f-45f8-9d91-ae7181164faf.png" alt="51157327-8b0f-45f8-9d91-ae7181164faf" border="0"></a>

## Логічна схема
На основі концептуальної моделі спроєктовано логічну схему бази даних. Створено такі таблиці (з полями, типами даних та зв’язками):
-   Employee – таблиця працівників. Поля: `emp_id` (ціле число, первинний ключ, автоматично генерується SERIAL), `name` (текст, ім’я користувача для входу), `role` (текст, роль користувача), `password_hash` (текст, пароль або його хеш). Первинний ключ – `emp_id`. Дані цієї таблиці використовуються для авторизації та визначення прав доступу (роль _admin_ має розширені права).
-   Client – таблиця клієнтів. Поля: `client_id` (SERIAL PK), `name` (текст, ім’я або назва клієнта), `contact_info` (текст, контактна інформація – телефон, email). Первинний ключ – `client_id`.
-   Car – таблиця автомобілів. Поля: `car_id` (SERIAL PK), `make` (текст, марка авто), `model` (текст, модель), `license_plate` (текст, номерний знак). Крім того, **`client_id`** (ціле число) – зовнішній ключ, що посилається на таблицю Client і визначає власника автомобіля. Первинний ключ – `car_id`. Зв’язок Client → Car реалізовано через `client_id` (один клієнт – багато автомобілів).
-   Service – таблиця довідника послуг. Поля: `service_id` (SERIAL PK), `name` (текст, назва послуги), `price` (numeric(10,2), ціна за одиницю послуги). Первинний ключ – `service_id`.
-   Order – таблиця замовлень. Поля: `order_id` (SERIAL PK), `date` (тип DATE або TIMESTAMP, дата створення замовлення), `status` (текст, статус замовлення, наприклад, _«Відкрите»_ або _«Закрито»_), `total_cost` (numeric(10,2), загальна вартість замовлення). Зовнішні ключі: `client_id` (посилання на Client – хто замовив), `car_id` (посилання на Car – який автомобіль обслуговується), **`emp_id`** (посилання на Employee – хто виконує). Кожне поле зовнішнього ключа має зв’язок з відповідною таблицею (зв’язки: Client–Order, Car–Order, Employee–Order). Первинний ключ – `order_id`. Щоб уникнути конфлікту з зарезервованим словом SQL, цю таблицю у запитах беруть в лапки як "Order".
-   OrderItem – таблиця позицій замовлення (деталізація послуг). Поля: `order_id` (ціле, зовнішній ключ на Order), `service_id` (ціле, зовнішній ключ на Service), `quantity` (ціле, кількість одиниць послуги). Первинний ключ композиційний – комбінація (`order_id`, `service_id`), оскільки одна й та сама послуга в межах замовлення зазначається єдиним записом з певною кількістю. Зв’язки: кожен запис OrderItem прив’язаний до конкретного замовлення і конкретної послуги (реалізує багато-до-багатьох між Order та Service).

<a href="https://ibb.co/nMTQ14PK"><img src="https://i.ibb.co/zV1P2C6t/40b57e35-36ec-452c-bfb2-16b7ef43c07d.png" alt="40b57e35-36ec-452c-bfb2-16b7ef43c07d" border="0"></a>

## Реалізація
Для створення структури бази даних та початкового наповнення було підготовлено SQL-скрипти. Спочатку створюються таблиці у правильному порядку (перше довідники та пов’язані таблиці, потім ті, що посилаються на них), після чого додаються необхідні записи.
Фрагменти скрипту створення таблиць:
```
-- Створення таблиць (схема бази даних "autoservice")
CREATE TABLE Employee (
    emp_id       SERIAL PRIMARY KEY,
    name         VARCHAR(100) NOT NULL,
    role         VARCHAR(20)  NOT NULL,
    password_hash VARCHAR(100) NOT NULL
);

CREATE TABLE Client (
    client_id    SERIAL PRIMARY KEY,
    name         VARCHAR(100) NOT NULL,
    contact_info TEXT
);

CREATE TABLE Car (
    car_id       SERIAL PRIMARY KEY,
    make         VARCHAR(50) NOT NULL,
    model        VARCHAR(50) NOT NULL,
    license_plate VARCHAR(20) UNIQUE NOT NULL,
    client_id    INT REFERENCES Client(client_id)
);

CREATE TABLE Service (
    service_id   SERIAL PRIMARY KEY,
    name         VARCHAR(100) NOT NULL,
    price        NUMERIC(10,2) NOT NULL
);

CREATE TABLE "Order" (
    order_id     SERIAL PRIMARY KEY,
    date         DATE NOT NULL DEFAULT CURRENT_DATE,
    status       VARCHAR(20) NOT NULL,
    total_cost   NUMERIC(10,2),
    client_id    INT REFERENCES Client(client_id),
    car_id       INT REFERENCES Car(car_id),
    emp_id       INT REFERENCES Employee(emp_id)
);

CREATE TABLE OrderItem (
    order_id   INT REFERENCES "Order"(order_id) ON DELETE CASCADE,
    service_id INT REFERENCES Service(service_id),
    quantity   INT NOT NULL,
    PRIMARY KEY(order_id, service_id)
);
```
Далі операції вставки даних для заповнення таблиць початковими даними:
```
-- Заповнення таблиці Employee (список працівників)
INSERT INTO Employee(name, role, password_hash) VALUES
('admin',    'admin',   'adminpass'),   -- адміністратор
('Іван Петренко', 'mechanic', 'ivan123'), 
('Петро Коваль',  'mechanic', 'petro123'),
('Оксана Сидоренко','manager','oxana123'),
('Марія Іванова',  'staff',   'maria123');

-- Заповнення таблиці Client (список клієнтів)
INSERT INTO Client(name, contact_info) VALUES
('ТОВ "АвтоПарк"', 'info@avtopark.ua'),
('Іван Іванов',    '+380501112233'),
('Олена Петренко', 'petrenko.olena@example.com'),
('ПП "Шиномонтаж"', '380631234567'),
('Сергій Бойко',   'boyko_serhii@gmail.com');

-- Заповнення таблиці Car (список автомобілів клієнтів)
INSERT INTO Car(make, model, license_plate, client_id) VALUES
('Toyota',  'Camry',   'AA0011BB', 2),  -- авто Івана Іванова
('Honda',   'Civic',   'AC1122AC', 3),  -- авто Олени Петренко
('Ford',    'Transit', 'AA7777HH', 1),  -- авто від компанії "АвтоПарк"
('BMW',     'X5',      'BK1234CH', 5),  -- авто Сергія Бойка
('Audi',    'A6',      'AA0007AA', 1);  -- ще один авто "АвтоПарк"

-- Заповнення таблиці Service (перелік послуг)
INSERT INTO Service(name, price) VALUES
('Заміна масла',          500.00),
('Діагностика двигуна',   300.00),
('Балансування коліс',    150.00),
('Заміна гальмівних колодок', 800.00),
('Мийка авто',            200.00),
('Шиномонтаж',            400.00);

-- Заповнення таблиці Order (кілька замовлень)
INSERT INTO "Order"(date, status, total_cost, client_id, car_id, emp_id) VALUES
('2025-10-01', 'Відкрите', NULL, 2, 1, 2),   -- замовлення від Івана Іванова, виконавець Іван Петренко
('2025-10-03', 'Відкрите', NULL, 3, 2, 2),   -- замовлення від Олени Петренко
('2025-10-05', 'Відкрите', NULL, 1, 3, 3),   -- замовлення від "АвтоПарк", виконавець Петро Коваль
('2025-10-07', 'Закрито', 1650.00, 1, 5, 4), -- виконане замовлення, сума прорахована
('2025-10-10', 'Відкрите', NULL, 5, 4, 2);

-- Заповнення таблиці OrderItem (позиції послуг у замовленнях)
INSERT INTO OrderItem(order_id, service_id, quantity) VALUES
(1, 1, 1),  -- у замовленні 1: послуга "Заміна масла" (1 раз)
(1, 2, 1),  -- у замовленні 1: послуга "Діагностика двигуна"
(2, 3, 4),  -- у замовленні 2: послуга "Балансування коліс" (4 колеса)
(4, 1, 1),  -- у замовленні 4: "Заміна масла"
(4, 4, 1),  -- у замовленні 4: "Заміна гальмівних колодок"
(4, 5, 1);  -- у замовленні 4: "Мийка авто"
```
## Налаштування Docker
Для спрощення розгортання системи використано контейнеризацію через Docker. Налаштування містяться у файлі `docker-compose.yml`, який описує два основні контейнери: базу даних та веб-застосунок.

-   Сервіс `db`: використовує офіційний образ Postgres 16. Встановлено змінні середовища для ініціалізації БД: назва бази (`autoservice`), користувач (`autoservice_user`), пароль (`strongpassword`). Ці дані використовуються для автоматичного створення бази та облікового запису. Порт 5432 контейнера проброшено на порт 5432 хоста для зручності підключення ( `ports: "5432:5432"` ). Для збереження даних БД між перезапусками підключено тому `db-data` до каталогу Postgres `/var/lib/postgresql/data`. Сервіс знаходиться у власній мережі `autoservice_net` (bridge).
    
-   Сервіс `web`: містить Flask-застосунок. У файлі Compose налаштовано збірку образу з Dockerfile (директива `build: .` означає контекст збірки – поточна папка проекту). Контейнер залежить від БД (`depends_on: db`), щоб гарантувати запуск Postgres перед веб-застосунком. Проброшено порт 5000 контейнера на 8000 хоста (`"8000:5000"`) для доступу до веб-інтерфейсу. Встановлено змінні середовища для підключення до БД (DB_HOST, DB_NAME, DB_USER, DB_PASS), що застосунок читає при запуску. Робоча директорія налаштована як `/app/autoservice_app` усередині контейнера, куди копіюється код проекту. Команда запуску – `python app.py`, що стартує Flask-сервер.
    

Файл Dockerfile містить кроки збірки образу веб-застосунку. Спершу базовим образом обрано `python:3.10-slim`. Далі встановлюються системні залежності, зокрема, шрифти (`xfonts-base`, `xfonts-75dpi`) та бібліотека `fontconfig` – це необхідно для коректної роботи пакета wkhtmltopdf (використовується для генерації PDF). Наступним кроком Dockerfile завантажує та встановлює wkhtmltopdf для Debian 12 (Bookworm) через .deb-пакет. Після цього копіюються файли проекту: спочатку `requirements.txt` і виконується `pip install` залежностей (серед яких Flask, psycopg2, pdfkit тощо), потім копіюється вихідний код програми (`autoservice_app`). Наприкінці задаються змінні середовища за замовчуванням для контейнера (ідентичні тим, що в docker-compose) та оголошується порт 8000, на якому працюватиме Flask. Команда запуску в Dockerfile дублює запуск сервера: `CMD ["python", "app.py"]`.

Запуск контейнерів: Для побудови та запуску контейнерів використовується Docker Compose. Основні команди:

1.  `docker-compose build` – зібрати Docker-образи для сервісів (виконає кроки, описані у Dockerfile).
2.  `docker-compose up -d` – запустити всі сервіси у фоні (ключ `-d`). Контейнер Postgres автоматично ініціалізує базу _autoservice_, а контейнер web підключається до неї за допомогою наданих змінних середовища.
3.  `docker-compose ps` – перевірити стан запущених контейнерів.
4.  `docker-compose logs -f web` – перегляд журналу застосунку.
5.  У браузері перейти на `http://localhost:8000` – перевірити доступність веб-інтерфейсу.
    
Керування контейнерами: В разі змін у коді або для налагодження можна перезапустити веб-сервіс командою `docker-compose restart web`. Щоб зупинити всі сервіси: `docker-compose down`. Docker автоматично створює мережу `autoservice_net` та тому `db-data` на основі конфігурації Compose, тому додатково вручну створювати мережі чи томи не потрібно – вони створюються при першому запуску.

## SQL-запити
Після наповнення бази даних можна виконувати різноманітні SQL-запити для отримання потрібної інформації. Кілька запитів:
-   Статистика кількості замовлень по місяцях: можна отримати, згрупувавши замовлення за місяцем дати. Запит SQL (використовує функцію TO_CHAR для форматування дати у формат Year-Month):
```
SELECT TO_CHAR(date, 'YYYY-MM') AS ym, COUNT(*) AS total_orders
FROM "Order"
GROUP BY ym
ORDER BY ym;
```
Цей запит поверне список місяців (YYYY-MM) та кількість замовлень у кожному з них. Аналогічний запит реалізовано і в застосунку для формування статистики на діаграмі (маршрут `/api/stats/orders_by_month`).
-   Статистика доходу по місяцях: щоб отримати дохід, беруться сумарні `total_cost` замовлень, що закриті в кожному місяці. Приклад запиту:
```
SELECT TO_CHAR(date, 'YYYY-MM') AS ym, SUM(total_cost) AS total_revenue
FROM "Order"
WHERE status = 'Закрито'
GROUP BY ym
ORDER BY ym;
```
Тут враховуються лише замовлення зі статусом _«Закрито»_, оскільки для відкритих замовлень підсумкову вартість ще не сформовано. Цей запит використовується у REST API застосунку для побудови графіку доходів (маршрут `/api/stats/revenue_by_month`).
-   CRUD-операції з клієнтами: у системі передбачені типові запити для створення, читання, оновлення та видалення записів клієнтів. Наприклад:
    -   Create (створення): `INSERT INTO Client(name, contact_info) VALUES ('Новий Клієнт', 'телефон/email');` – додає нового клієнта. В веб-застосунку це виконується через форму додавання клієнта.
    -   Read (читання): `SELECT client_id, name, contact_info FROM Client;` – вибір всіх клієнтів (використовується щоб відобразити список клієнтів).
    -   Update (оновлення): `UPDATE Client SET name='Інше Ім’я', contact_info='нові дані' WHERE client_id=...;` – змінює дані клієнта за його ID. Викликається при редагуванні клієнта.
    -   Delete (видалення): `DELETE FROM Client WHERE client_id=...;` – видаляє клієнта. Використовується на сторінці списку клієнтів при натисканні «Видалити».
 
Подібні CRUD-запити реалізовані і для інших сутностей (наприклад, для автомобілів або послуг – додавання нового автомобіля, оновлення інформації про послугу тощо). У REST API також присутні ендпоїнти для CRUD операцій над клієнтами – зокрема, `GET /api/clients` (список клієнтів), `POST /api/clients` (створити нового), `PUT /api/clients/<id>` (оновити) та `DELETE /api/clients/<id>` (видалити).

## Консольний застосунок
Окрім веб-інтерфейсу, доступ до бази даних можна отримати через консолі, наприклад, з використанням утиліти psql. В контейнерізованому середовищі для цього використовується команда Docker:
``` 
docker exec -it lab4autoservice-db-1 psql -U autoservice_user autoservice
```
Ця команда відкриває інтерактивну консоль psql всередині контейнера Postgres, підключаючись до бази _lab4autoservice-db-1_ під користувачем _autoservice_user_.

<a href="https://ibb.co/C3srLRMp"><img src="https://i.ibb.co/Q3j50yC7/cmd.png" alt="cmd" border="0"></a><br /><a target='_blank' href='https://uk.imgbb.com/'></a>

## Вебзастосунок
<a href="https://ibb.co/WpVyVjMb"><img src="https://i.ibb.co/84Y5YtfW/login.png" alt="login" border="0"></a><br /><a target='_blank' href='https://uk.imgbb.com/'></a><br />
<a href="https://ibb.co/j93Y1bzj"><img src="https://i.ibb.co/CpVyTm6S/orders.png" alt="orders" border="0"></a><br /><a target='_blank' href='https://uk.imgbb.com/'></a><br />
<a href="https://ibb.co/1YbDgKP3"><img src="https://i.ibb.co/cKxGBtZP/rahunokpdf.png" alt="rahunokpdf" border="0"></a><br /><a target='_blank' href='https://uk.imgbb.com/'></a><br />
<a href="https://ibb.co/Lz9v4Mt9"><img src="https://i.ibb.co/1fRbH3qR/clients.png" alt="clients" border="0"></a><br /><a target='_blank' href='https://uk.imgbb.com/'></a><br />
<a href="https://ibb.co/wZHQC6RS"><img src="https://i.ibb.co/1YVXK2Lr/newclients.png" alt="newclients" border="0"></a><br /><a target='_blank' href='https://uk.imgbb.com/'></a><br />

## Розширена функціональність
Генерація рахунку в PDF: Система може формувати рахунок-фактуру (інвойс) для замовлення у форматі PDF. Це реалізовано через маршрут `/orders/<id>/invoice.pdf`, який доступний для авторизованих користувачів. При зверненні до нього застосунок вибирає з бази усі дані по замовленню – інформацію про замовлення (дату, клієнта, авто, виконавця, статус, суму) та список послуг із їх ціною і кількістю. Ці дані підставляються в HTML-шаблон `invoice.html`, після чого бібліотека pdfkit конвертує цей HTML у PDF-файл. Готовий PDF повертається користувачу як файл, що завантажується (через Flask `Response` з відповідним MIME-типом). Для коректної роботи pdfkit у контейнері були встановлені утиліти wkhtmltopdf та шрифти (див. Dockerfile) – без цього генерація PDF викликала б помилки рендерингу. В результаті клієнт може отримати рахунок з детальним переліком виконаних робіт і вартістю по кожному пункту.
Додано сторінку Dashboard з графіками.

## Висновки
В ході лабораторної роботи №4 було розроблено і реалізовано інформаційну систему "Автосервіс" з використанням СУБД PostgreSQL, Flask та технологій контейнеризації (Docker).
Окремо варто відзначити освоєння Docker: створено Dockerfile для образу застосунку та docker-compose.yml для оркестрації сервісів. В результаті застосунок легко запускати в ізольованому середовищі. Були виявлені і подолані певні труднощі при розробці:
-   Проблеми зі збіркою Docker-образу: спочатку виникала помилка при генерації PDF (wkhtmltopdf) через відсутність необхідних шрифтів та компонентів. Цю проблему вирішено шляхом встановлення додаткових пакетів (`xfonts-base`, `xfonts-75dpi`, `fontconfig`) та прямої інсталяції відповідної версії wkhtmltopdf. Після цього контейнер успішно збирався без помилок.
-   Налаштування томів і мереж: при першому налаштуванні Docker Compose була неточність у іменах томів/мереж, що призводило до помилок (Volume чи Network not found). В процесі налагодження було виправлено ім’я тому (наприклад, використано `db-data` замість `db_data` у всіх місцях consistently) та явно оголошено мережу `autoservice_net` у файлі Compose. Після цього зв’язок між контейнерами налагодився.
-   Черговість створення таблиць та зв’язки: під час виконання SQL-скриптів стало зрозуміло, що необхідно правильно впорядкувати команди CREATE TABLE з урахуванням зовнішніх ключів. Перші спроби створення всіх таблиць одночасно призводили до помилок, оскільки таблиці посилалися на ще не існуючі. Цю проблему вирішено розбиттям скрипту на частини або додаванням опції `CREATE TABLE ... IF NOT EXISTS` та повторним запуском. Аналогічно, при завантаженні початкових даних треба було дотримуватися черговості вставок (спочатку довідники, потім основні записи). Після впорядкування операцій всі дані успішно додалися.

-   Інтеграція Flask з БД: при розробці виникали дрібні помилки, наприклад, невідповідність імен полів або параметрів запиту. Вони були успішно знайдені через перегляд логів Flask та виправлені. Також напрацьовано навички роботи з сесіями Flask для контролю доступу.
